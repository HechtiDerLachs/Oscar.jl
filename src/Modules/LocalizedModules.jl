export default_ordering, singular_assure, saturated_modulus, kernel, singular_gens, oscar_assure

#promotion for scalar multiplication
AbstractAlgebra.promote_rule(::Type{RET}, ::Type{MET}) where {RET<:RingElem, MET<:ModuleElem} = MET

# for localizations of polynomial rings, the singular side 
# can not be filled out with fractions, but only with the 
# numerators of generators. Thus we need a specialized routine 
# for this.
function singular_assure(M::ModuleGens{T}) where {T<:MPolyLocalizedRingElem}
  isdefined(M, :SF) && isdefined(M, :S) && return
  L = base_ring(M)
  R = base_ring(L)
  F = ambient_free_module(M)
  # set up the singular side
  SR = singular_ring(R, singular(default_ordering(F))) # why does an Oscar module have a `default_ordering`?
  SF = Singular.FreeModule(SR, ngens(F))
  # applying a singular ring to a fraction clears denominators, see below.
  sgens_and_denoms = [SF(a) for a in oscar_generators(M)]
  M.SF = SF
  M.S = Singular.Module(SR, [a[1] for a in sgens_and_denoms]...)
end

function singular_gens(M::ModuleGens) 
  singular_assure(M)
  return M.S
end

function Base.iterate(L::Singular.smodule, i::Int)
  n = ngens(L)
  if i <= n 
    return L[i], i+1
  else
    return nothing
  end
end

Base.iterate(L::Singular.smodule) = iterate(L, 1)

Base.eltype(::Type{Singular.smodule}) = Singular.svector

Base.length(L::Singular.smodule) = ngens(L)

function oscar_assure(M::ModuleGens{T}) where {T<:MPolyLocalizedRingElem}
  isdefined(M, :O) && return
  L = base_ring(M)
  R = base_ring(L)
  F = ambient_free_module(M)
  M.O = [F(v) for v in singular_gens(M)]
  return 
end

function (F::FreeMod{T})(v::Singular.svector) where {T<:MPolyLocalizedRingElem}
  L = base_ring(M)
  R = base_ring(L)
  return sum([R(a)*e for (a, e) in zip(Array(v), gens(F))])
end



function (SF::Singular.FreeMod)(v::FreeModElem{T}) where {T<:MPolyLocalizedRingElem}
  F = parent(v)
  L = base_ring(F)
  R = base_ring(L)
  SR = base_ring(SF)
  # find a common denominator for the components of this generator
  d = lcm(denominator.(Vector(v)))
  new_numerators = [numerator(v[i])*divexact(d, denominator(v[i])) for i in 1:ngens(F)]
  # and return the linear combination of the new numerators together with its denominators
  return sum([SR(new_numerators[i])*gens(SF)[i] for i in 1:length(new_numerators)]), SR(d)
end

# this case is special, because it needs to also apply a shift
function (SF::Singular.FreeMod)(v::FreeModElem{T}) where {T<:MPolyLocalizedRingElem{<:Any, <:Any, <:Any, <:Any, <:MPolyComplementOfKPointIdeal}}
  F = parent(v)
  L = base_ring(F)
  R = base_ring(L)
  SR = base_ring(SF)
  a = point_coordinates(inverted_set(L))
  f = hom(R, R, [x-a for (x, a) in zip(gens(R), a)])

  # find a common denominator for the components of this generator
  d = lcm(denominator.(Vector(v)))
  new_numerators = [numerator(v[i])*divexact(d, denominator(v[i])) for i in 1:ngens(F)]
  # and return the linear combination of the new numerators
  return sum([SR(f(new_numerators[i]))*gens(SF)[i] for i in 1:length(new_numerators)]), SR(f(d))
end

# return the singular submodule generated by a list of elements together with its denominators
function (SF::Singular.FreeMod)(v::Vector{FreeModElem{T}}) where {T<:MPolyLocalizedRingElem}
  svd = [SF(a) for a in v]
  return Singular.Module(base_ring(SF), [a[1] for a in svd]...), [a[2] for a in svd]
end

function default_ordering(F::FreeModuleType) where {FreeModuleType<:FreeMod{<:MPolyLocalizedRingElem{<:Any, <:Any, <:Any, <:Any, <:MPolyComplementOfKPointIdeal}}}
  # We need to set up a free module over the polynomial ring 
  # so that the monomial ordering can be given.
  L = base_ring(F)
  R = base_ring(L)
  helperF = FreeMod(R, ngens(F))
  # TODO: Ask for a constructor of module orderings that works without setting up such a module 
  # explicitly!
  return negdegrevlex(gens(base_ring(base_ring(F))))*lex(gens(helperF))
end

# the default module ordering assumes that we're computing in a global ring
function default_ordering(F::FreeMod{T}) where {T<:MPolyLocalizedRingElem}
  # We need to set up a free module over the polynomial ring 
  # so that the monomial ordering can be given.
  L = base_ring(F)
  R = base_ring(L)
  helperF = FreeMod(R, ngens(F))
  return degrevlex(gens(base_ring(base_ring(F))))*lex(gens(helperF))
end

# given an m×n-matrix A with entries in a localization R[U⁻¹] we bring each 
# row to a common denominator 1//dᵢ ⋅ (bᵢ₁,…,bᵢₙ) and return the pair 
# (B, d) of the matrix B and the vector d.
function _clear_row_denominators(
    A::AbstractAlgebra.Generic.MatSpaceElem{RET}
  ) where {RET<:MPolyLocalizedRingElem}
  L = base_ring(A)
  R = base_ring(L)
  denom_A = denominator.(A)
  d = [lcm([denom_A[i, j] for j in 1:ncols(A)]) for i in 1:nrows(A)]
  cleared_A = MatrixSpace(R,nrows(A), ncols(A))(vcat([[numerator(A[i, j])*div(d[i], denominator(A[i,j])) for j in 1:ncols(A)] for i in 1:nrows(A)]...))
  return cleared_A, d
end

function kernel(f::FreeModuleHom{FreeMod{BRET}, FreeMod{BRET}}) where {BRET<:MPolyLocalizedRingElem{<:Any, <:Any, <:Any, <:Any, <:MPolyComplementOfKPointIdeal}}
  F = domain(f)
  L = base_ring(F)
  R = base_ring(L)
  G = codomain(f)
  point_coordinates(inverted_set(L))

  A = matrix(f)
  cleared_A, denom_A = _clear_row_denominators(A)
  cAS = _to_singular_gens(cleared_A, shift=point_coordinates(inverted_set(L)))
  KS = Singular.syz(cAS)
  K = _to_oscar_gens(F, KS, denominators=denom_A)
  return K, hom(K, F, ambient_representatives_generators(K))
end

function kernel(f::FreeModuleHom{FreeMod{BRET}, FreeMod{BRET}}) where {BRET<:MPolyLocalizedRingElem}
  F = domain(f)
  L = base_ring(F)
  R = base_ring(L)
  G = codomain(f)

  A = matrix(f)
  cleared_A, denom_A = _clear_row_denominators(A)
  cAS = _to_singular_gens(cleared_A)
  KS = Singular.syz(cAS)
  K = _to_oscar_gens(F, KS, denominators=denom_A)
  return K, hom(K, F, ambient_representatives_generators(K))
end

using Infiltrator
function kernel(f::FreeModuleHom{FreeMod{BRET}, SubQuo{BRET}}) where {BRET<:MPolyLocalizedRingElem{<:Any, <:Any, <:Any, <:Any, <:MPolyComplementOfKPointIdeal}}
  F = domain(f)
  L = base_ring(F)
  R = base_ring(L)
  G = codomain(f)

  A = matrix(f)
  cleared_A, denom_A = _clear_row_denominators(A)
  A_smod = _to_singular_gens(cleared_A, shift=point_coordinates(inverted_set(L)))
  smodulus = _to_singular_gens(ambient_free_module(G), relations(G))
  sK = Singular.modulo(A_smod, smodulus)
  K = _to_oscar_gens(F, sK, denominators=denom_A)
  return K, hom(K, F, ambient_representatives_generators(K))
end

function kernel(f::FreeModuleHom{FreeMod{BRET}, SubQuo{BRET}}) where {BRET<:MPolyLocalizedRingElem}
  F = domain(f)
  L = base_ring(F)
  R = base_ring(L)
  G = codomain(f)

  A = matrix(f)
  cleared_A, denom_A = _clear_row_denominators(A)
  A_smod = _to_singular_gens(cleared_A)
  smodulus = _to_singular_gens(saturated_modulus(codomain(f)))
  sK = Singular.modulo(A_smod, smodulus)
  K = _to_oscar_gens(F, sK, denominators=denom_A)
  return K, hom(K, F, ambient_representatives_generators(K))
end

function saturated_modulus(M::SubQuo{BRET}) where {BRET<:MPolyLocalizedRingElem{<:Any, <:Any, <:Any, <:Any, <:MPolyPowersOfElement}}
  if !has_attribute(M, :saturated_modulus)
    L = base_ring(M)
    R = base_ring(L)
    A_clear, _ = ambient_representatives_generators(M)
    B_clear, _ = relations(M)
    SR = singular_poly_ring(R)
    A_mod = Singular.Module(Singular.Matrix(SR, SR.(transpose(cleared_A))))
    B_mod = Singular.Module(Singular.Matrix(SR, SR.(transpose(cleared_B))))
    AB_mod = A_mod + B_mod
    for d in denominators(inverted_set(L))
      AB_mod = Singular.saturation(AB_mod, Singular.Ideal(SR, [SR(d)]))
    end
    AB_vec = [R.(Array(AB_mod[i])) for i in 1:ngens(AB_mod)]
    F = ambient_module(M)
    B_sat = sub(F, [sum([v[i]*denom_A[i]*F[i] for i in 1:ngens(F)]) for v in AB_vec])
    set_attribute!(M, :saturated_modulus, B_sat)
  end
  return get_attribute(M, :saturated_modulus)::SubQuo{BRET}
end

function _to_singular_gens(
    A::AbstractAlgebra.Generic.MatSpaceElem{RET};
    shift=Vector{elem_type(coefficient_ring(base_ring(A)))}()
  ) where {RET<:MPolyElem}
  R = base_ring(A)
  SR = singular_poly_ring(R)
  if length(shift) > 0
    @assert length(shift) == ngens(R)
    sha = hom(R, R, [x-a for (x, a) in zip(gens(R), shift)])
    return Singular.Module(Singular.Matrix(SR, SR.(transpose(sha.(A)))))
  end
  return Singular.Module(Singular.Matrix(SR, SR.(transpose(A))))
end

function _to_singular_gens(
    F::FreeMod{T},
    v::Vector{FreeModElem{T}}
  ) where {T<:MPolyLocalizedRingElem}
  L = base_ring(F)
  R = base_ring(L)
  SR = singular_poly_ring(R)
  
  length(v) == 0 && return Singular.Module(Singular.Matrix(SR, [zero(SR) for i in 1:ngens(F)]))

  for a in v
    parent(a) === F || error("element does not belong to the correct parent")
  end

  SF = Singular.FreeModule(SR, ngens(F))
  return Singular.Module(SR, [SF(a)[1] for a in v]...)
end

function _to_oscar_gens(
    F::FreeMod{T},
    A::Singular.smodule;
    denominators=[one(base_ring(base_ring(F))) for i in 1:ngens(F)]
  ) where {T<:MPolyLocalizedRingElem{<:Any, <:Any, <:Any, <:Any, <:MPolyComplementOfKPointIdeal}}
  L = base_ring(F)
  R = base_ring(L)
  shainv = hom(R, R, [x+a for (x, a) in zip(gens(R), point_coordinates(inverted_set(L)))])
  A_vec = [shainv.(R.(Array(A[i]))) for i in 1:ngens(A)]
  AO = sub(F, [sum([v[i]*denominators[i]*F[i] for i in 1:ngens(F)]) for v in A_vec])
  return AO
end

# default without a shift
function _to_oscar_gens(
    F::FreeMod{T},
    A::Singular.smodule;
    denominators=[one(base_ring(base_ring(F))) for i in 1:ngens(F)]
  ) where {T<:MPolyLocalizedRingElem}
  R = base_ring(F)
  A_vec = [R.(Array(A[i])) for i in 1:ngens(A)]
  AO = sub(F, [sum([v[i]*denominators[i]*F[i] for i in 1:ngens(F)]) for v in A_vec])
  return AO
end

function Base.in(v::FreeModElem{T}, M::SubQuo{T}) where {T<:MPolyLocalizedRingElem}
  parent(v) === ambient_free_module(M) || return false
  L = base_ring(M)
  R = base_ring(L)
  SR = singular_poly_ring(R)
end

function groebner_bases(M::SubQuo{T}) where {T<:MPolyLocalizedRingElem}
  return M.groebner_basis
end

function groebner_basis(M::SubQuo{T}) where {T<:MPolyLocalizedRingElem}
  F = ambient_free_module(M)
  if !haskey(groebner_bases(M), default_ordering(F))
    L = base_ring(M)
    R = base_ring(L)
    SR = singular_poly_ring(R)
    SM = _to_singular_gens(F, ambient_representatives_generators(M))
    SMstd = Singular.std(SM)
    gbM = ModuleGens(F, SMstd)
    leadM = ModuleGens(F, Singular.lead(SMstd))
    gb = Oscar.ModuleGB(gbM, leadM, default_ordering(F))
    groebner_bases(M)[default_ordering(F)] = gb
  end
  return groebner_bases(M)[default_ordering(F)]
end
